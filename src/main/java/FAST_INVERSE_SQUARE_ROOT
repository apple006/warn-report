    平方根倒数速算法

    原文：http://www.matrix67.com/data/InvSqrt.pdf

    摘要：很多程序不可避免的要计算平方根倒数，例如3D游戏中的正规化矢量。通常，为了大幅提高运算速度而损失一些精度是可以接受的。本文是对一些网上链接库的源码中发现的快速算法的讨论和改进，并提供了推导出其他类似算法的思路。

    一.引言
    在www.gamedev.net的数学编程论坛上，我看到一个有趣的方法计算平方根倒数。下面是C的代码和我加的注释：
    float InvSqrt(float x)
    {
        float xhalf = 0.5f*x;
        int i = *(int*)&x; // get bits for floating value
        i = 0x5f3759df - (i>>1); // gives initial guess y0
        x = *(float*)&i; // convert bits back to float
        x = x*(1.5f-xhalf*x*x); // Newton step, repeating increases accuracy(牛顿迭代，用重复计算来增加精度)
        return x;
    }
    0x5f3759df这个常量非常有趣：它是哪来的，工作原理是什么？通过VC++做的一些快速测试显示这个方法速度比原生的(float)(1.0/sqrt(x))方法快近乎4倍，并且所有浮点数中最大相对误差仅有0.00175228，所以这个方法看上去非常有用。对此有三个直接的问题：1).它是怎么工作的，2).是否可以改进，3).哪个高手设计了这样一个难以置信的东西？
    快速用Google搜索了几次0x5f3759df ，最贴近的是2002.1.9的一段线程comp.graphics.algorithms的一个引用了它的线程的代码，和一个D. Eberly的解释（错误，但是贴近）。然而他的解释是有启发性的。更进一步的挖掘也没有找到正确的说明。一个传说中的程序员在Quake 3的源码里写了它。
    Eberly对平方根倒数插值的线性变化更清楚的解释了使用这个算法的动机。本文记录了一些提升这段代码速度的方法，但是并不会更进一步推进优化。有一些例如表查找的类似加速方法，但是其中大多数的精度都不如这个方法。
    本文假定PC使用32位浮点和整形或类似架构。特别之处浮点表示标准使用的是IEEE 754-1985。这段C的代码确认是端中性（译注：并不事先确定是big还是little）的（据说在Macintosh上测试过）。不过我没有验证过。由于方法是以32位工作的它应该（令人惊讶的）是端中性的。本文的观点是它很容易扩展为适应其他场景（比如double类型）。无论如何，主要还是那三个问题。

    二.背景
